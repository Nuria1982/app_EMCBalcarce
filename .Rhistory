stopifnot(isTRUE(resp$ok), !is.null(resp$data))
d <- resp$data
tibble(
Fecha = as.Date(as.POSIXct(d$start / 1000, origin = "1970-01-01", tz = "UTC")),
Temperatura_Abrigo_150cm = (d$temperature_max + d$temperature_min) / 2,
Temperatura_Abrigo_150cm_Minima = d$temperature_min,
Precipitacion_Pluviometrica = d$rain,
Riego = 0
# Evapotranspiracion_Potencial la completamos abajo
)
}
meteored_forecast_to_df <- function(resp_vec) {
dplyr::bind_rows(lapply(resp_vec, meteored_day_to_df)) |>
arrange(Fecha) |>
distinct(Fecha, .keep_all = TRUE)
}
meteored_forecast_to_df
library(httr2)
install.packages("httr2")
library(httr2)
get_meteored_daily5 <- function(hash, api_key, base_url = "https://www.theweather.com") {
req <- request(paste0(base_url, "/api/forecast/v1/daily/", hash)) |>
req_headers(`x-api-key` = api_key) |>
req_timeout(20)
resp <- req_perform(req)
json <- resp_body_json(resp)
if (!isTRUE(json$ok)) stop("Meteored API ok != TRUE")
# OJO: según el endpoint, puede ser:
# - json$data = lista de 5 días (ideal)
# - o json$data = 1 día (como tu ejemplo) y venga en otro campo el array
x <- json$data
# Si viene un solo día:
if (!is.list(x[[1]]) || !("start" %in% names(x[[1]]))) {
x <- list(x)
}
df <- bind_rows(lapply(x, function(d) {
tibble(
Fecha = as.Date(as.POSIXct(d$start / 1000, origin = "1970-01-01", tz = "UTC")),
Tmax  = as.numeric(d$temperature_max),
Tmin  = as.numeric(d$temperature_min),
Precipitacion_Pluviometrica = as.numeric(d$rain)
)
})) |>
mutate(
Temperatura_Abrigo_150cm = (Tmax + Tmin) / 2,
Temperatura_Abrigo_150cm_Minima = Tmin,
Riego = 0
# Evapotranspiracion_Potencial la calculamos abajo (si Meteored no la trae)
) |>
select(
Fecha,
Temperatura_Abrigo_150cm,
Temperatura_Abrigo_150cm_Minima,
Riego,
Precipitacion_Pluviometrica
) |>
arrange(Fecha) |>
distinct(Fecha, .keep_all = TRUE)
df
}
get_meteored_daily5
fc_balcarce <- reactive({
req(input$usar_pronostico)
req(input$meteored_api_key)
req(input$hash_balcarce)     # hash de Balcarce
req(input$lat_balcarce)      # lat de Balcarce (ej -37.83 aprox)
df_fc <- get_meteored_daily5(
hash = input$hash_balcarce,
api_key = input$meteored_api_key
)
df_fc |>
add_et0_hargreaves_fc(lat_deg = input$lat_balcarce)
})
get_location_by_postalcode <- function(code, api_key, base_url = "https://www.theweather.com") {
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = api_key) |>
req_timeout(20)
resp <- req_perform(req)
json <- resp_body_json(resp)
if (!isTRUE(json$ok)) stop("Location search: ok != TRUE")
# La estructura exacta puede variar (a veces json$data es lista, a veces trae results/items)
# Intentamos encontrar una lista de resultados
dat <- json$data
if (is.null(dat)) stop("Location search: json$data es NULL (revisar estructura)")
# Si viene como lista de resultados:
# devolvemos el primero y con campos comunes
# Ajustá estos nombres cuando pegues un ejemplo real.
if (is.list(dat) && length(dat) > 0 && is.list(dat[[1]])) {
d <- dat[[1]]
} else {
d <- dat
}
list(
hash = d$hash,
name = d$name,
url  = d$url
)
}
code <- "B7620"   # o el código que estés usando
base_url <- "https://www.theweather.com"
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
code <- "B7620"   # o el código que estés usando
base_url <- "https://www.theweather.com"
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
json <- resp_body_json(resp)
base_url <- "https://www.meteored.com"
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
base_url <- "https://api.meteored.com"
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
nzchar(Sys.getenv("METEORED_API_KEY"))
nchar(Sys.getenv("METEORED_API_KEY"))
Sys.setenv(METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14")
code <- "B7620"   # o el código que estés usando
base_url <- "https://api.meteored.com"
nzchar(Sys.getenv("METEORED_API_KEY"))
nchar(Sys.getenv("METEORED_API_KEY"))
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
json <- resp_body_json(resp)
library(jsonlite)
cat(toJSON(json, pretty = TRUE, auto_unbox = TRUE))
names(json)
names(json$data)
str(json$data, max.level = 3)
cand <- json$data
if (is.list(cand) && length(cand) > 0 && is.list(cand[[1]])) {
first <- cand[[1]]
} else {
first <- cand
}
hash <- first$hash
name <- first$name
url  <- first$url
hash
name
url
str(json, max.level = 4)
code <- "28013"
req <- request(paste0("https://api.meteored.com/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
json_es <- req_perform(req) |> resp_body_json()
cat(jsonlite::toJSON(json_es, pretty=TRUE, auto_unbox=TRUE))
str(json, max.level = 4)
locs <- search_locations_txt("Balcarce Buenos Aires Argentina", Sys.getenv("METEORED_API_KEY"))
locs
search_locations_txt <- function(text, api_key, base_url = "https://api.meteored.com") {
req <- request(paste0(base_url, "/api/location/v1/search/txt/", URLencode(text, reserved = TRUE))) |>
req_headers(`x-api-key` = api_key) |>
req_timeout(20)
j <- req_perform(req) |> resp_body_json()
stopifnot(isTRUE(j$ok))
locs <- j$data$locations
if (length(locs) == 0) return(tibble())
bind_rows(lapply(locs, function(x) {
tibble(
hash = x$hash,
name = x$name,
description = x$description,
country_name = x$country_name
)
}))
}
locs <- search_locations_txt("Balcarce Buenos Aires Argentina", Sys.getenv("METEORED_API_KEY"))
locs
HASH_BALCARCE <- "157d85bea5cc30774a422ca476dd1b73"
hash_balcarce <- locs |>
filter(
tolower(name) == "balcarce",
tolower(description) == "buenos aires",
tolower(country_name) == "argentina"
) |>
slice(1) |>
pull(hash)
get_forecast_daily5_full <- function(hash, api_key, base_url = "https://api.meteored.com") {
req <- request(paste0(base_url, "/api/forecast/v1/daily/", hash)) |>
req_headers(`x-api-key` = api_key) |>
req_timeout(20)
j <- req_perform(req) |> resp_body_json()
stopifnot(isTRUE(j$ok))
d <- j$data
if (is.list(d) && !is.null(d$start)) d <- list(d)  # normaliza a lista
bind_rows(lapply(d, function(x) {
tmin <- as.numeric(x$temperature_min)
tmax <- as.numeric(x$temperature_max)
tibble(
Fecha = as.Date(as.POSIXct(x$start/1000, origin="1970-01-01", tz="UTC")),
Tmin  = tmin,
Tmax  = tmax,
Precipitacion_Pluviometrica = as.numeric(x$rain),
Riego = 0
)
})) |>
arrange(Fecha) |>
distinct(Fecha, .keep_all = TRUE) |>
mutate(
Temperatura_Abrigo_150cm = (Tmin + Tmax)/2,
Temperatura_Abrigo_150cm_Minima = Tmin
)
}
get_forecast_daily5_full
usethis::edit_r_environ()
install.packages("usethis")
librray(usethis)
library(usethis)
usethis::edit_r_environ()
Sys.getenv("METEORED_API_KEY")
nzchar(Sys.getenv("METEORED_API_KEY"))
usethis::use_git_ignore(".Renviron")
shiny::runApp()
fc_balcarce <- reactive({
req(input$usar_pronostico)
req(input$meteored_api_key)
req(input$hash_balcarce)     # hash de Balcarce
req(input$lat_balcarce)      # lat de Balcarce (ej -37.83 aprox)
df_fc <- get_meteored_daily5(
hash = input$hash_balcarce,
api_key = input$meteored_api_key
)
df_fc |>
add_et0_hargreaves_fc(lat_deg = input$lat_balcarce)
})
serie_balance_balcarce <- reactive({
obs <- datos_actualizados()
if (!isTRUE(input$usar_pronostico)) return(obs)
mutate(Fecha = as.Date(Fecha)) %>%
select(Fecha, Temperatura_Abrigo_150cm, Temperatura_Abrigo_150cm_Minima,
Riego, Precipitacion_Pluviometrica, Evapotranspiracion_Potencial) %>%
arrange(Fecha)
hoy <- Sys.Date()
fc_raw <- get_forecast_daily5_full(HASH_BALCARCE, Sys.getenv("METEORED_API_KEY"))
fc <- add_et0_hargreaves(fc_raw, lat_deg = LAT_BALCARCE)
bind_rows(
obs %>% filter(Fecha <= hoy),
fc  %>% filter(Fecha >  hoy)
) %>%
arrange(Fecha) %>%
distinct(Fecha, .keep_all = TRUE)
})
datos_filtrados <- serie_balance_balcarce() %>%
filter(Fecha >= input$fecha_siembra_balcarce) %>%
select(Fecha, Temperatura_Abrigo_150cm, Temperatura_Abrigo_150cm_Minima, Riego, Precipitacion_Pluviometrica, Evapotranspiracion_Potencial)
datos_filtrados <- serie_balance_balcarce() %>%
filter(Fecha >= input$fecha_siembra_balcarce) %>%
select(Fecha, Temperatura_Abrigo_150cm, Temperatura_Abrigo_150cm_Minima, Riego, Precipitacion_Pluviometrica, Evapotranspiracion_Potencial)
datos_filtrados <- datos_filtrados %>%
mutate(Dia_Mes = format(Fecha, "%m-%d"))
runApp()
x <- get_fc_cached()
runApp()
runApp()
runApp()
runApp()
runApp()
renv::status()
renv::restore()
renv::status()
renv::snapshot() #para capturar todas las dependencias
# renv::snapshot() #para capturar todas las dependencias
renv::status() #para ver si hay paquetes no instalados
runApp()
rsconnect::setAccountInfo(name='intabalcarce',
token='77F02260172FAF69FBFBEA5CCA574B99',
secret='u8vt3UUrp8R9AfAnasDLAwmQilGTd4LctZy9ebnj')
rsconnect::deployApp(appDir = "I:/TRABAJO/CERBAS/GrupoAgrometeorologia/App_Meteo", appPrimaryDoc = "app.R",
appName = "Agromet", account = 'intabalcarce', server = 'shinyapps.io')
rsconnect::setEnvVars(
appName = "Agromet",
envVars = c(METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14")
)
# rsconnect::setAccountInfo(name='intabalcarce',
#                           token='77F02260172FAF69FBFBEA5CCA574B99',
#                           secret='u8vt3UUrp8R9AfAnasDLAwmQilGTd4LctZy9ebnj')
# rsconnect::deployApp(appDir = "I:/TRABAJO/CERBAS/GrupoAgrometeorologia/App_Meteo", appPrimaryDoc = "app.R",
#                      appName = "Agromet", account = 'intabalcarce', server = 'shinyapps.io')
packageVersion("rsconnect")
rsconnect::setEnvVars(
appName = "Agromet",
envVars = c(METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14")
)
find.package("rsconnect")
getNamespaceExports("rsconnect")[grep("setEnv", getNamespaceExports("rsconnect"))]
runApp()
runApp()
rsconnect::setEnvVars(
envVars = c(METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14")
)
rsconnect:::setEnvVars(
envVars = c(
METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14"
)
)
renv::repair()
test_meteored <- function() {
api_key <- assert_meteored_key()
req <- httr2::request("https://api.meteored.com/api/location/v1/search/txt/Balcarce") |>
httr2::req_headers(`x-api-key` = api_key) |>
httr2::req_timeout(20)
resp <- httr2::req_perform(req)
message("Meteored test status: ", httr2::resp_status(resp))
if (httr2::resp_status(resp) >= 400) {
message(substr(httr2::resp_body_string(resp), 1, 500))
stop("Meteored test failed")
}
TRUE
}
test_meteored()
get_meteored_key <- function() {
key <- Sys.getenv("METEORED_API_KEY")
if (!nzchar(key)) key <- getOption("METEORED_API_KEY")
if (!nzchar(key)) stop("METEORED_API_KEY is missing (env var and option are empty).")
key
}
assert_meteored_key <- function() {
key <- get_meteored_key()
message("Using METEORED key length = ", nchar(key))
invisible(key)
}
get_forecast_daily5_full <- function(hash, base_url = "https://api.meteored.com") {
api_key <- get_meteored_key()
req <- httr2::request(paste0(base_url, "/api/forecast/v1/daily/", hash)) |>
httr2::req_headers(`x-api-key` = api_key) |>
httr2::req_timeout(20)
api_key <- assert_meteored_key()
resp <- httr2::req_perform(req)
status <- httr2::resp_status(resp)
if (status >= 400) {
message("Meteored HTTP status: ", status)
# intenta leer body (a veces trae JSON con mensaje)
body_txt <- tryCatch(httr2::resp_body_string(resp), error = function(e) "<no body>")
message("Meteored error body: ", substr(body_txt, 1, 500))
stop("Meteored request failed")
}
j <- httr2::resp_body_json(resp)
}
message("METEORED_API_KEY length = ", nchar(Sys.getenv("METEORED_API_KEY")))
message("METEORED_API_KEY (option) length = ", nchar(getOption("METEORED_API_KEY")))
test_meteored <- function() {
api_key <- assert_meteored_key()
req <- httr2::request("https://api.meteored.com/api/location/v1/search/txt/Balcarce") |>
httr2::req_headers(`x-api-key` = api_key) |>
httr2::req_timeout(20)
resp <- httr2::req_perform(req)
message("Meteored test status: ", httr2::resp_status(resp))
if (httr2::resp_status(resp) >= 400) {
message(substr(httr2::resp_body_string(resp), 1, 500))
stop("Meteored test failed")
}
TRUE
}
test_meteored()
locs <- search_locations_txt("Balcarce Buenos Aires Argentina")  # usando tu versión que toma la key adentro
search_locations_txt <- function(text, base_url = "https://api.meteored.com") {
api_key <- get_meteored_key()
req <- httr2::request(paste0(base_url, "/api/location/v1/search/txt/", URLencode(text, reserved = TRUE))) |>
httr2::req_headers(`x-api-key` = api_key) |>
httr2::req_timeout(20)
api_key <- assert_meteored_key()
j <- httr2::req_perform(req) |> httr2::resp_body_json()
stopifnot(isTRUE(j$ok))
locs <- j$data$locations
if (length(locs) == 0) return(tibble::tibble())
dplyr::bind_rows(lapply(locs, function(x) {
tibble::tibble(
hash = x$hash,
name = x$name,
description = x$description,
country_name = x$country_name
)
}))
}
locs <- search_locations_txt("Balcarce Buenos Aires Argentina")
locs
hash_balcarce <- locs |>
filter(
tolower(name) == "balcarce",
tolower(description) == "buenos aires",
tolower(country_name) == "argentina"
) |>
slice(1) |>
pull(hash)
hash_balcarce <- locs |>
dplyr::filter(
tolower(name) == "balcarce",
tolower(description) == "buenos aires",
tolower(country_name) == "argentina"
) |>
dplyr::slice(1) |>
dplyr::pull(hash)
message("HASH BALCARCE = ", hash_balcarce, " (nchar=", nchar(hash_balcarce), ")")
test_forecast <- function(hash) {
api_key <- assert_meteored_key()
url <- paste0("https://api.meteored.com/api/forecast/v1/daily/", hash)
message("Forecast URL = ", url)
req <- httr2::request(url) |>
httr2::req_headers(`x-api-key` = api_key) |>
httr2::req_timeout(20)
resp <- httr2::req_perform(req)
message("Forecast status: ", httr2::resp_status(resp))
if (httr2::resp_status(resp) >= 400) {
body_txt <- tryCatch(httr2::resp_body_string(resp), error = function(e) "<no body>")
message("Body: ", substr(body_txt, 1, 800))
stop("Forecast failed")
}
j <- httr2::resp_body_json(resp)
message("ok = ", j$ok)
invisible(j)
}
test_forecast(hash_balcarce)
file.exists("config.R")
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
shiny::runApp()
runApp()
shiny::runApp()
runApp()
runApp()
min_safe_date <- function(x) {
x <- as.Date(x)
x <- x[is.finite(x)]
if (length(x) == 0) return(as.Date(NA))
min(x, na.rm = TRUE)
}
max_safe_date <- function(x) {
x <- as.Date(x)
x <- x[is.finite(x)]
if (length(x) == 0) return(as.Date(NA))
max(x, na.rm = TRUE)
}
runApp()
runApp()
runApp()
runApp()
runApp()
min_safe_date <- function(x) {
x <- as.Date(x)
x <- x[!is.na(x)]
if (length(x) == 0) return(as.Date(NA))
min(x)
}
max_safe_date <- function(x) {
x <- as.Date(x)
x <- x[!is.na(x)]
if (length(x) == 0) return(as.Date(NA))
max(x)
}
max_safe_num <- function(x) {
x <- as.numeric(x)
x <- x[is.finite(x)]
if (length(x) == 0) return(NA_real_)
max(x)
}
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
