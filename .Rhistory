) %>%
filter(Temperatura_Abrigo_150cm_Minima <= 3) %>%
group_by(Año) %>%
summarise(
primera = min(dia_norm),
ultima  = max(dia_norm),
fecha_primera = as.Date(primera - 1, origin = "1950-01-01"),
fecha_ultima  = as.Date(ultima  - 1, origin = "1950-01-01"),
.groups = "drop"
)
View(heladas_anuales)
heladas_anuales <- balcarce_EMC %>%
filter(Año >= 1970, Año <= 2025,
!is.na(Temperatura_Abrigo_150cm_Minima)) %>%
mutate(
fecha = as.Date(Fecha),
dia_juliano = yday(fecha),
dia_norm = if_else(leap_year(Año) & dia_juliano >= 60,
dia_juliano + 1,
dia_juliano)
) %>%
filter(Temperatura_Abrigo_150cm_Minima <= 3) %>%
group_by(Año) %>%
summarise(
primera = min(dia_norm),
ultima  = max(dia_norm),
fecha_primera = as.Date(primera - 1, origin = "1950-01-01"),
fecha_ultima  = as.Date(ultima  - 1, origin = "1950-01-01"),
.groups = "drop"
)
View(heladas_anuales)
heladas_periodo_3 <- function(df, start_year, end_year) {
df %>%
filter(Año >= start_year, Año <= end_year,
!is.na(Temperatura_Abrigo_150cm_Minima)) %>%
mutate(
fecha = as.Date(Fecha),
dia_juliano = yday(fecha),
dia_norm = if_else(leap_year(Año) & dia_juliano >= 60,
dia_juliano + 1,
dia_juliano)
) %>%
filter(Temperatura_Abrigo_150cm_Minima <= 3) %>%
group_by(Año) %>%
summarise(
primera = min(dia_norm),
ultima  = max(dia_norm),
.groups = "drop"
) %>%
summarise(
periodo = paste0(start_year, "-", end_year),
primera_media = mean(primera, na.rm = TRUE),
ultima_media  = mean(ultima, na.rm = TRUE),
.groups = "drop"
) %>%
mutate(
fecha_primera_media = as.Date(primera_media, origin = "1800-12-31"),
fecha_ultima_media  = as.Date(ultima_media, origin = "1800-12-31")
)
}
h1 <- heladas_periodo_3(balcarce_EMC, 1971, 2000)
h1
h2 <- heladas_periodo_3(balcarce_EMC, 1981, 2010)
h3 <- heladas_periodo_3(balcarce_EMC, 1991, 2020)
h4 <- heladas_periodo_3(balcarce_EMC, 2016, 2025)
h2
h3
h4 <- heladas_periodo_3(balcarce_EMC, 2016, 2025)
h4
h4 <- heladas_periodo_3(balcarce_EMC, 2016, 2024)
h4
runApp()
runApp()
runApp()
shiny::runApp()
library(rsconnect)
library(shiny)
library(shinyWidgets)
library(shinydashboard)
library(shinycssloaders)
library(DT)
library(tidyr)
library(ggplot2)
library(plotly)
library(dplyr)
library(bslib)
library(shinythemes)
library(bs4Dash)
library(lubridate)
library(png)
library(readxl)
library(writexl)
library(leaflet)
library(webshot)
library(httr)
library(jsonlite)
# library(DBI)
# library(RSQLite)
# library(digest)
# library(googlesheets4)
# gs4_auth()
library(broom)
library(purrr)
library(minpack.lm)
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
# library(patchwork)
gitcreds::gitcreds_set()
install.packages("gitcreds")
# library(patchwork)
library(gitcreds)
gitcreds::gitcreds_set()
gitcreds::gitcreds_delete()
gitcreds::gitcreds_set()
gitcreds::gitcreds_get()
gitcreds::gitcreds_delete()
gitcreds::gitcreds_set()
gitcreds::gitcreds_get()
shiny::runApp()
runApp()
shiny::runApp()
ra_mj_m2_day <- function(lat_deg, doy) {
Gsc <- 0.0820
phi <- lat_deg * pi/180
dr  <- 1 + 0.033 * cos(2*pi/365 * doy)
delta <- 0.409 * sin(2*pi/365 * doy - 1.39)
ws <- acos(pmax(-1, pmin(1, -tan(phi) * tan(delta))))
(24*60/pi) * Gsc * dr * (ws*sin(phi)*sin(delta) + cos(phi)*cos(delta)*sin(ws))
}
et0_hargreaves <- function(tmax, tmin, tmean, ra) {
0.0023 * ra * (tmean + 17.8) * sqrt(pmax(0, tmax - tmin))
}
fc_balcarce <- reactive({
req(input$usar_pronostico)
req(input$lat_balcarce)   # lat para ET0 (o hardcode Balcarce)
# TODO: reemplazar por tu llamada real a Meteored que devuelva varios días
# fc_list <- get_meteored_forecast(...)
# donde cada elemento tiene: start, temperature_max, temperature_min, rain
fc_list <- list()  # placeholder
df <- dplyr::bind_rows(lapply(fc_list, function(x) {
tibble::tibble(
Fecha = as.Date(as.POSIXct(x$data$start/1000, origin="1970-01-01", tz="UTC")),
Tmax  = x$data$temperature_max,
Tmin  = x$data$temperature_min,
Precipitacion_Pluviometrica = x$data$rain,
Riego = 0
)
})) %>%
mutate(
Temperatura_Abrigo_150cm = (Tmax + Tmin)/2,
Temperatura_Abrigo_150cm_Minima = Tmin,
doy = yday(Fecha),
Ra = ra_mj_m2_day(input$lat_balcarce, doy),
Evapotranspiracion_Potencial = et0_hargreaves(Tmax, Tmin, Temperatura_Abrigo_150cm, Ra)
) %>%
select(
Fecha,
Temperatura_Abrigo_150cm,
Temperatura_Abrigo_150cm_Minima,
Riego,
Precipitacion_Pluviometrica,
Evapotranspiracion_Potencial
) %>%
arrange(Fecha) %>%
distinct(Fecha, .keep_all = TRUE)
df
})
meteored_day_to_df <- function(resp) {
stopifnot(isTRUE(resp$ok), !is.null(resp$data))
d <- resp$data
tibble(
Fecha = as.Date(as.POSIXct(d$start / 1000, origin = "1970-01-01", tz = "UTC")),
Temperatura_Abrigo_150cm = (d$temperature_max + d$temperature_min) / 2,
Temperatura_Abrigo_150cm_Minima = d$temperature_min,
Precipitacion_Pluviometrica = d$rain,
Riego = 0
# Evapotranspiracion_Potencial la completamos abajo
)
}
meteored_forecast_to_df <- function(resp_vec) {
dplyr::bind_rows(lapply(resp_vec, meteored_day_to_df)) |>
arrange(Fecha) |>
distinct(Fecha, .keep_all = TRUE)
}
meteored_forecast_to_df
library(httr2)
install.packages("httr2")
library(httr2)
get_meteored_daily5 <- function(hash, api_key, base_url = "https://www.theweather.com") {
req <- request(paste0(base_url, "/api/forecast/v1/daily/", hash)) |>
req_headers(`x-api-key` = api_key) |>
req_timeout(20)
resp <- req_perform(req)
json <- resp_body_json(resp)
if (!isTRUE(json$ok)) stop("Meteored API ok != TRUE")
# OJO: según el endpoint, puede ser:
# - json$data = lista de 5 días (ideal)
# - o json$data = 1 día (como tu ejemplo) y venga en otro campo el array
x <- json$data
# Si viene un solo día:
if (!is.list(x[[1]]) || !("start" %in% names(x[[1]]))) {
x <- list(x)
}
df <- bind_rows(lapply(x, function(d) {
tibble(
Fecha = as.Date(as.POSIXct(d$start / 1000, origin = "1970-01-01", tz = "UTC")),
Tmax  = as.numeric(d$temperature_max),
Tmin  = as.numeric(d$temperature_min),
Precipitacion_Pluviometrica = as.numeric(d$rain)
)
})) |>
mutate(
Temperatura_Abrigo_150cm = (Tmax + Tmin) / 2,
Temperatura_Abrigo_150cm_Minima = Tmin,
Riego = 0
# Evapotranspiracion_Potencial la calculamos abajo (si Meteored no la trae)
) |>
select(
Fecha,
Temperatura_Abrigo_150cm,
Temperatura_Abrigo_150cm_Minima,
Riego,
Precipitacion_Pluviometrica
) |>
arrange(Fecha) |>
distinct(Fecha, .keep_all = TRUE)
df
}
get_meteored_daily5
fc_balcarce <- reactive({
req(input$usar_pronostico)
req(input$meteored_api_key)
req(input$hash_balcarce)     # hash de Balcarce
req(input$lat_balcarce)      # lat de Balcarce (ej -37.83 aprox)
df_fc <- get_meteored_daily5(
hash = input$hash_balcarce,
api_key = input$meteored_api_key
)
df_fc |>
add_et0_hargreaves_fc(lat_deg = input$lat_balcarce)
})
get_location_by_postalcode <- function(code, api_key, base_url = "https://www.theweather.com") {
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = api_key) |>
req_timeout(20)
resp <- req_perform(req)
json <- resp_body_json(resp)
if (!isTRUE(json$ok)) stop("Location search: ok != TRUE")
# La estructura exacta puede variar (a veces json$data es lista, a veces trae results/items)
# Intentamos encontrar una lista de resultados
dat <- json$data
if (is.null(dat)) stop("Location search: json$data es NULL (revisar estructura)")
# Si viene como lista de resultados:
# devolvemos el primero y con campos comunes
# Ajustá estos nombres cuando pegues un ejemplo real.
if (is.list(dat) && length(dat) > 0 && is.list(dat[[1]])) {
d <- dat[[1]]
} else {
d <- dat
}
list(
hash = d$hash,
name = d$name,
url  = d$url
)
}
code <- "B7620"   # o el código que estés usando
base_url <- "https://www.theweather.com"
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
code <- "B7620"   # o el código que estés usando
base_url <- "https://www.theweather.com"
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
json <- resp_body_json(resp)
base_url <- "https://www.meteored.com"
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
base_url <- "https://api.meteored.com"
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
nzchar(Sys.getenv("METEORED_API_KEY"))
nchar(Sys.getenv("METEORED_API_KEY"))
Sys.setenv(METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14")
code <- "B7620"   # o el código que estés usando
base_url <- "https://api.meteored.com"
nzchar(Sys.getenv("METEORED_API_KEY"))
nchar(Sys.getenv("METEORED_API_KEY"))
req <- request(paste0(base_url, "/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
resp <- req_perform(req)
json <- resp_body_json(resp)
library(jsonlite)
cat(toJSON(json, pretty = TRUE, auto_unbox = TRUE))
names(json)
names(json$data)
str(json$data, max.level = 3)
cand <- json$data
if (is.list(cand) && length(cand) > 0 && is.list(cand[[1]])) {
first <- cand[[1]]
} else {
first <- cand
}
hash <- first$hash
name <- first$name
url  <- first$url
hash
name
url
str(json, max.level = 4)
code <- "28013"
req <- request(paste0("https://api.meteored.com/api/location/v1/search/postalcode/", code)) |>
req_headers(`x-api-key` = Sys.getenv("METEORED_API_KEY")) |>
req_timeout(20)
json_es <- req_perform(req) |> resp_body_json()
cat(jsonlite::toJSON(json_es, pretty=TRUE, auto_unbox=TRUE))
str(json, max.level = 4)
locs <- search_locations_txt("Balcarce Buenos Aires Argentina", Sys.getenv("METEORED_API_KEY"))
locs
search_locations_txt <- function(text, api_key, base_url = "https://api.meteored.com") {
req <- request(paste0(base_url, "/api/location/v1/search/txt/", URLencode(text, reserved = TRUE))) |>
req_headers(`x-api-key` = api_key) |>
req_timeout(20)
j <- req_perform(req) |> resp_body_json()
stopifnot(isTRUE(j$ok))
locs <- j$data$locations
if (length(locs) == 0) return(tibble())
bind_rows(lapply(locs, function(x) {
tibble(
hash = x$hash,
name = x$name,
description = x$description,
country_name = x$country_name
)
}))
}
locs <- search_locations_txt("Balcarce Buenos Aires Argentina", Sys.getenv("METEORED_API_KEY"))
locs
HASH_BALCARCE <- "157d85bea5cc30774a422ca476dd1b73"
hash_balcarce <- locs |>
filter(
tolower(name) == "balcarce",
tolower(description) == "buenos aires",
tolower(country_name) == "argentina"
) |>
slice(1) |>
pull(hash)
get_forecast_daily5_full <- function(hash, api_key, base_url = "https://api.meteored.com") {
req <- request(paste0(base_url, "/api/forecast/v1/daily/", hash)) |>
req_headers(`x-api-key` = api_key) |>
req_timeout(20)
j <- req_perform(req) |> resp_body_json()
stopifnot(isTRUE(j$ok))
d <- j$data
if (is.list(d) && !is.null(d$start)) d <- list(d)  # normaliza a lista
bind_rows(lapply(d, function(x) {
tmin <- as.numeric(x$temperature_min)
tmax <- as.numeric(x$temperature_max)
tibble(
Fecha = as.Date(as.POSIXct(x$start/1000, origin="1970-01-01", tz="UTC")),
Tmin  = tmin,
Tmax  = tmax,
Precipitacion_Pluviometrica = as.numeric(x$rain),
Riego = 0
)
})) |>
arrange(Fecha) |>
distinct(Fecha, .keep_all = TRUE) |>
mutate(
Temperatura_Abrigo_150cm = (Tmin + Tmax)/2,
Temperatura_Abrigo_150cm_Minima = Tmin
)
}
get_forecast_daily5_full
usethis::edit_r_environ()
install.packages("usethis")
librray(usethis)
library(usethis)
usethis::edit_r_environ()
Sys.getenv("METEORED_API_KEY")
nzchar(Sys.getenv("METEORED_API_KEY"))
usethis::use_git_ignore(".Renviron")
shiny::runApp()
fc_balcarce <- reactive({
req(input$usar_pronostico)
req(input$meteored_api_key)
req(input$hash_balcarce)     # hash de Balcarce
req(input$lat_balcarce)      # lat de Balcarce (ej -37.83 aprox)
df_fc <- get_meteored_daily5(
hash = input$hash_balcarce,
api_key = input$meteored_api_key
)
df_fc |>
add_et0_hargreaves_fc(lat_deg = input$lat_balcarce)
})
serie_balance_balcarce <- reactive({
obs <- datos_actualizados()
if (!isTRUE(input$usar_pronostico)) return(obs)
mutate(Fecha = as.Date(Fecha)) %>%
select(Fecha, Temperatura_Abrigo_150cm, Temperatura_Abrigo_150cm_Minima,
Riego, Precipitacion_Pluviometrica, Evapotranspiracion_Potencial) %>%
arrange(Fecha)
hoy <- Sys.Date()
fc_raw <- get_forecast_daily5_full(HASH_BALCARCE, Sys.getenv("METEORED_API_KEY"))
fc <- add_et0_hargreaves(fc_raw, lat_deg = LAT_BALCARCE)
bind_rows(
obs %>% filter(Fecha <= hoy),
fc  %>% filter(Fecha >  hoy)
) %>%
arrange(Fecha) %>%
distinct(Fecha, .keep_all = TRUE)
})
datos_filtrados <- serie_balance_balcarce() %>%
filter(Fecha >= input$fecha_siembra_balcarce) %>%
select(Fecha, Temperatura_Abrigo_150cm, Temperatura_Abrigo_150cm_Minima, Riego, Precipitacion_Pluviometrica, Evapotranspiracion_Potencial)
datos_filtrados <- serie_balance_balcarce() %>%
filter(Fecha >= input$fecha_siembra_balcarce) %>%
select(Fecha, Temperatura_Abrigo_150cm, Temperatura_Abrigo_150cm_Minima, Riego, Precipitacion_Pluviometrica, Evapotranspiracion_Potencial)
datos_filtrados <- datos_filtrados %>%
mutate(Dia_Mes = format(Fecha, "%m-%d"))
runApp()
x <- get_fc_cached()
runApp()
runApp()
runApp()
runApp()
runApp()
renv::status()
renv::restore()
renv::status()
renv::snapshot() #para capturar todas las dependencias
# renv::snapshot() #para capturar todas las dependencias
renv::status() #para ver si hay paquetes no instalados
runApp()
rsconnect::setAccountInfo(name='intabalcarce',
token='77F02260172FAF69FBFBEA5CCA574B99',
secret='u8vt3UUrp8R9AfAnasDLAwmQilGTd4LctZy9ebnj')
rsconnect::deployApp(appDir = "I:/TRABAJO/CERBAS/GrupoAgrometeorologia/App_Meteo", appPrimaryDoc = "app.R",
appName = "Agromet", account = 'intabalcarce', server = 'shinyapps.io')
rsconnect::setEnvVars(
appName = "Agromet",
envVars = c(METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14")
)
# rsconnect::setAccountInfo(name='intabalcarce',
#                           token='77F02260172FAF69FBFBEA5CCA574B99',
#                           secret='u8vt3UUrp8R9AfAnasDLAwmQilGTd4LctZy9ebnj')
# rsconnect::deployApp(appDir = "I:/TRABAJO/CERBAS/GrupoAgrometeorologia/App_Meteo", appPrimaryDoc = "app.R",
#                      appName = "Agromet", account = 'intabalcarce', server = 'shinyapps.io')
packageVersion("rsconnect")
rsconnect::setEnvVars(
appName = "Agromet",
envVars = c(METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14")
)
find.package("rsconnect")
getNamespaceExports("rsconnect")[grep("setEnv", getNamespaceExports("rsconnect"))]
runApp()
runApp()
rsconnect::setEnvVars(
envVars = c(METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14")
)
rsconnect:::setEnvVars(
envVars = c(
METEORED_API_KEY = "c214226148f6a0adb2b766b49b6b494415dd8d41dd0085fcd729d595fd7fae14"
)
)
renv::repair()
